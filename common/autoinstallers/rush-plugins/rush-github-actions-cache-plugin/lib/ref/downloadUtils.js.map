{"version":3,"file":"downloadUtils.js","sourceRoot":"","sources":["../../src/ref/downloadUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport * as core from '@actions/core'\nimport {HttpClient, HttpClientResponse} from '@actions/http-client'\nimport {BlockBlobClient} from '@azure/storage-blob'\nimport {TransferProgressEvent} from '@azure/ms-rest-js'\nimport * as buffer from 'buffer'\nimport * as stream from 'stream'\nimport * as util from 'util'\n\nimport {SocketTimeout} from './constants'\nimport {DownloadOptions} from './options'\nimport {retryHttpClientResponse} from './requestUtils'\n\n// import {AbortController} from '@azure/abort-controller'\n\nexport type ChunkWriteCallback = (chunk: Buffer, count: number | undefined, offset: number | undefined) => Promise<void> | void\n\n/**\n * Pipes the body of a HTTP response to a stream\n *\n * @param response the HTTP response\n * @param output the writable stream\n */\nasync function pipeResponseToStream(\n  response: HttpClientResponse,\n  output: NodeJS.WritableStream\n): Promise<void> {\n  const pipeline = util.promisify(stream.pipeline)\n  await pipeline(response.message, output)\n}\n\n/**\n * Class for tracking the download state and displaying stats.\n */\nexport class DownloadProgress {\n  contentLength: number\n  segmentIndex: number\n  segmentSize: number\n  segmentOffset: number\n  receivedBytes: number\n  startTime: number\n  displayedComplete: boolean\n  timeoutHandle?: ReturnType<typeof setTimeout>\n\n  constructor(contentLength: number) {\n    this.contentLength = contentLength\n    this.segmentIndex = 0\n    this.segmentSize = 0\n    this.segmentOffset = 0\n    this.receivedBytes = 0\n    this.displayedComplete = false\n    this.startTime = Date.now()\n  }\n\n  /**\n   * Progress to the next segment. Only call this method when the previous segment\n   * is complete.\n   *\n   * @param segmentSize the length of the next segment\n   */\n  nextSegment(segmentSize: number): void {\n    this.segmentOffset = this.segmentOffset + this.segmentSize\n    this.segmentIndex = this.segmentIndex + 1\n    this.segmentSize = segmentSize\n    this.receivedBytes = 0\n\n    core.debug(\n      `Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`\n    )\n  }\n\n  /**\n   * Sets the number of bytes received for the current segment.\n   *\n   * @param receivedBytes the number of bytes received\n   */\n  setReceivedBytes(receivedBytes: number): void {\n    this.receivedBytes = receivedBytes\n  }\n\n  /**\n   * Returns the total number of bytes transferred.\n   */\n  getTransferredBytes(): number {\n    return this.segmentOffset + this.receivedBytes\n  }\n\n  /**\n   * Returns true if the download is complete.\n   */\n  isDone(): boolean {\n    return this.getTransferredBytes() === this.contentLength\n  }\n\n  /**\n   * Prints the current download stats. Once the download completes, this will print one\n   * last line and then stop.\n   */\n  display(): void {\n    if (this.displayedComplete) {\n      return\n    }\n\n    const transferredBytes = this.segmentOffset + this.receivedBytes\n    const percentage = (100 * (transferredBytes / this.contentLength)).toFixed(\n      1\n    )\n    const elapsedTime = Date.now() - this.startTime\n    const downloadSpeed = (\n      transferredBytes /\n      (1024 * 1024) /\n      (elapsedTime / 1000)\n    ).toFixed(1)\n\n    core.info(\n      `Received ${transferredBytes} of ${this.contentLength} (${percentage}%), ${downloadSpeed} MBs/sec`\n    )\n\n    if (this.isDone()) {\n      this.displayedComplete = true\n    }\n  }\n\n  /**\n   * Returns a function used to handle TransferProgressEvents.\n   */\n  onProgress(): (progress: TransferProgressEvent) => void {\n    return (progress: TransferProgressEvent) => {\n      this.setReceivedBytes(progress.loadedBytes)\n    }\n  }\n\n  /**\n   * Starts the timer that displays the stats.\n   *\n   * @param delayInMs the delay between each write\n   */\n  startDisplayTimer(delayInMs = 1000): void {\n    const displayCallback = (): void => {\n      this.display()\n\n      if (!this.isDone()) {\n        this.timeoutHandle = setTimeout(displayCallback, delayInMs)\n      }\n    }\n\n    this.timeoutHandle = setTimeout(displayCallback, delayInMs)\n  }\n\n  /**\n   * Stops the timer that displays the stats. As this typically indicates the download\n   * is complete, this will display one last line, unless the last line has already\n   * been written.\n   */\n  stopDisplayTimer(): void {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle)\n      this.timeoutHandle = undefined\n    }\n\n    this.display()\n  }\n}\n\n/**\n * Download the cache using the Actions toolkit http-client\n *\n * @param archiveLocation the URL for the cache\n * @param archivePath the local path where the cache is saved\n */\nexport async function downloadCacheHttpClient(\n  archiveLocation: string,\n  onChunk: ChunkWriteCallback,\n  getWrittenLength: () => number\n): Promise<void> {\n  const httpClient = new HttpClient('actions/cache')\n  const downloadResponse = await retryHttpClientResponse(\n    'downloadCache',\n    async () => httpClient.get(archiveLocation)\n  )\n\n  // Abort download if no traffic received over the socket.\n  downloadResponse.message.socket.setTimeout(SocketTimeout, () => {\n    downloadResponse.message.destroy()\n    core.debug(`Aborting download, socket timed out after ${SocketTimeout} ms`)\n  })\n\n  // readBodyBuffer is always defined in http-client\n  const responseBuffer: Buffer = await downloadResponse.readBodyBuffer!()\n  onChunk(responseBuffer, undefined, undefined)\n\n  // Validate download size.\n  const contentLengthHeader = downloadResponse.message.headers['content-length']\n\n  if (contentLengthHeader) {\n    const expectedLength = parseInt(contentLengthHeader)\n    const actualLength = getWrittenLength()\n\n    if (actualLength !== expectedLength) {\n      throw new Error(\n        `Incomplete download. Expected file size: ${expectedLength}, actual file size: ${actualLength}`\n      )\n    }\n  } else {\n    core.debug('Unable to validate download, no Content-Length header')\n  }\n}\n\n/**\n * Download the cache using the Actions toolkit http-client concurrently\n *\n * @param archiveLocation the URL for the cache\n * @param archivePath the local path where the cache is saved\n */\nexport async function downloadCacheHttpClientConcurrent(\n  archiveLocation: string,\n  onChunk: ChunkWriteCallback,\n  options: DownloadOptions\n): Promise<void> {\n  const httpClient = new HttpClient('actions/cache', undefined, {\n    socketTimeout: options.timeoutInMs,\n    keepAlive: true\n  })\n  try {\n    const res = await retryHttpClientResponse(\n      'downloadCacheMetadata',\n      async () => await httpClient.request('HEAD', archiveLocation, null, {})\n    )\n\n    const lengthHeader = res.message.headers['content-length']\n    if (lengthHeader === undefined || lengthHeader === null) {\n      throw new Error('Content-Length not found on blob response')\n    }\n\n    const length = parseInt(lengthHeader)\n    if (Number.isNaN(length)) {\n      throw new Error(`Could not interpret Content-Length: ${length}`)\n    }\n\n    const downloads: {\n      offset: number\n      promiseGetter: () => Promise<DownloadSegment>\n    }[] = []\n    const blockSize = 4 * 1024 * 1024\n\n    for (let offset = 0; offset < length; offset += blockSize) {\n      const count = Math.min(blockSize, length - offset)\n      downloads.push({\n        offset,\n        promiseGetter: async () => {\n          return await downloadSegmentRetry(\n            httpClient,\n            archiveLocation,\n            offset,\n            count\n          )\n        }\n      })\n    }\n\n    // reverse to use .pop instead of .shift\n    downloads.reverse()\n    let actives = 0\n    let bytesDownloaded = 0\n    const progress = new DownloadProgress(length)\n    progress.startDisplayTimer()\n    const progressFn = progress.onProgress()\n\n    const activeDownloads: {[offset: number]: Promise<DownloadSegment>} = []\n    let nextDownload:\n      | {offset: number; promiseGetter: () => Promise<DownloadSegment>}\n      | undefined\n\n    const waitAndWrite: () => Promise<void> = async () => {\n      const { buffer, count, offset} = await Promise.race(Object.values(activeDownloads))\n      onChunk(buffer, count, offset)\n      actives--\n      delete activeDownloads[offset]\n      bytesDownloaded += count\n      progressFn({loadedBytes: bytesDownloaded})\n    }\n\n    while ((nextDownload = downloads.pop())) {\n      activeDownloads[nextDownload.offset] = nextDownload.promiseGetter()\n      actives++\n\n      if (actives >= (options.downloadConcurrency ?? 10)) {\n        await waitAndWrite()\n      }\n    }\n\n    while (actives > 0) {\n      await waitAndWrite()\n    }\n  } finally {\n    httpClient.dispose()\n  }\n}\n\nasync function downloadSegmentRetry(\n  httpClient: HttpClient,\n  archiveLocation: string,\n  offset: number,\n  count: number\n): Promise<DownloadSegment> {\n  const retries = 5\n  let failures = 0\n\n  while (true) {\n    try {\n      const timeout = 30000\n      const result = await promiseWithTimeout(\n        timeout,\n        downloadSegment(httpClient, archiveLocation, offset, count)\n      )\n      if (typeof result === 'string') {\n        throw new Error('downloadSegmentRetry failed due to timeout')\n      }\n\n      return result\n    } catch (err) {\n      if (failures >= retries) {\n        throw err\n      }\n\n      failures++\n    }\n  }\n}\n\nasync function downloadSegment(\n  httpClient: HttpClient,\n  archiveLocation: string,\n  offset: number,\n  count: number\n): Promise<DownloadSegment> {\n  const partRes = await retryHttpClientResponse(\n    'downloadCachePart',\n    async () =>\n      await httpClient.get(archiveLocation, {\n        Range: `bytes=${offset}-${offset + count - 1}`\n      })\n  )\n\n  if (!partRes.readBodyBuffer) {\n    throw new Error('Expected HttpClientResponse to implement readBodyBuffer')\n  }\n\n  return {\n    offset,\n    count,\n    buffer: await partRes.readBodyBuffer()\n  }\n}\n\ndeclare class DownloadSegment {\n  offset: number\n  count: number\n  buffer: Buffer\n}\n\n/**\n * Download the cache using the Azure Storage SDK.  Only call this method if the\n * URL points to an Azure Storage endpoint.\n *\n * @param archiveLocation the URL for the cache\n * @param archivePath the local path where the cache is saved\n * @param options the download options with the defaults set\n */\nexport async function downloadCacheStorageSDK(\n  archiveLocation: string,\n  onChunk: ChunkWriteCallback,\n  getWrittenLength: () => number,\n  options: DownloadOptions\n): Promise<void> {\n  const client = new BlockBlobClient(archiveLocation, undefined, {\n    retryOptions: {\n      // Override the timeout used when downloading each 4 MB chunk\n      // The default is 2 min / MB, which is way too slow\n      tryTimeoutInMs: options.timeoutInMs\n    }\n  })\n\n  const properties = await client.getProperties()\n  const contentLength = properties.contentLength ?? -1\n\n  if (contentLength < 0) {\n    // We should never hit this condition, but just in case fall back to downloading the\n    // file as one large stream\n    core.debug(\n      'Unable to determine content length, downloading file with http-client...'\n    )\n\n    await downloadCacheHttpClient(archiveLocation, onChunk, getWrittenLength)\n  } else {\n    // Use downloadToBuffer for faster downloads, since internally it splits the\n    // file into 4 MB chunks which can then be parallelized and retried independently\n    //\n    // If the file exceeds the buffer maximum length (~1 GB on 32-bit systems and ~2 GB\n    // on 64-bit systems), split the download into multiple segments\n    // ~2 GB = 2147483647, beyond this, we start getting out of range error. So, capping it accordingly.\n\n    // Updated segment size to 128MB = 134217728 bytes, to complete a segment faster and fail fast\n    const maxSegmentSize = Math.min(134217728, buffer.constants.MAX_LENGTH)\n    const downloadProgress = new DownloadProgress(contentLength)\n\n    try {\n      downloadProgress.startDisplayTimer()\n      // const controller = new AbortController()\n      // const abortSignal = controller.signal\n      while (!downloadProgress.isDone()) {\n        const segmentStart =\n          downloadProgress.segmentOffset + downloadProgress.segmentSize\n\n        const segmentSize = Math.min(\n          maxSegmentSize,\n          contentLength - segmentStart\n        )\n\n        downloadProgress.nextSegment(segmentSize)\n        const result = await promiseWithTimeout(\n          options.segmentTimeoutInMs || 3600000,\n          client.downloadToBuffer(segmentStart, segmentSize, {\n            // abortSignal,\n            concurrency: options.downloadConcurrency,\n            onProgress: downloadProgress.onProgress()\n          })\n        )\n        if (result === 'timeout') {\n          // controller.abort()\n          throw new Error(\n            'Aborting cache download as the download time exceeded the timeout.'\n          )\n        } else if (Buffer.isBuffer(result)) {\n          onChunk(result, undefined, undefined)\n        }\n      }\n    } finally {\n      downloadProgress.stopDisplayTimer()\n    }\n  }\n}\n\nconst promiseWithTimeout = async <T>(\n  timeoutMs: number,\n  promise: Promise<T>\n): Promise<T | string> => {\n  let timeoutHandle: NodeJS.Timeout\n  const timeoutPromise = new Promise<string>(resolve => {\n    timeoutHandle = setTimeout(() => resolve('timeout'), timeoutMs)\n  })\n\n  return Promise.race([promise, timeoutPromise]).then(result => {\n    clearTimeout(timeoutHandle)\n    return result\n  })\n}\n"]}