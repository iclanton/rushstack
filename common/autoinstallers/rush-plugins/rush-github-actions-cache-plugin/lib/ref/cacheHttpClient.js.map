{"version":3,"file":"cacheHttpClient.js","sourceRoot":"","sources":["../../src/ref/cacheHttpClient.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable */\nimport * as core from '@actions/core'\nimport {HttpClient} from '@actions/http-client'\nimport {BearerCredentialHandler} from '@actions/http-client/lib/auth'\nimport {\n  RequestOptions,\n  TypedResponse\n} from '@actions/http-client/lib/interfaces'\nimport * as crypto from 'crypto'\nimport * as fs from 'fs'\nimport {URL} from 'url'\nimport {Readable as ReadableStream} from 'stream';\n\nimport * as utils from './cacheUtils'\nimport {CompressionMethod} from './constants'\nimport {\n  ArtifactCacheEntry,\n  InternalCacheOptions,\n  CommitCacheRequest,\n  ReserveCacheRequest,\n  ReserveCacheResponse,\n  ITypedResponseWithError,\n  ArtifactCacheList\n} from './contracts'\nimport {\n  type ChunkWriteCallback,\n  downloadCacheHttpClient,\n  downloadCacheHttpClientConcurrent,\n  downloadCacheStorageSDK\n} from './downloadUtils'\nimport {\n  DownloadOptions,\n  UploadOptions,\n  getDownloadOptions,\n  getUploadOptions\n} from './options'\nimport {\n  isSuccessStatusCode,\n  retryHttpClientResponse,\n  retryTypedResponse\n} from './requestUtils'\n\nconst versionSalt = '1.0'\n\ntype GetStreamForChunk = (start: number, end: number) => NodeJS.ReadableStream\n\nfunction getCacheApiUrl(resource: string): string {\n  const baseUrl: string = process.env['ACTIONS_CACHE_URL'] || ''\n  if (!baseUrl) {\n    throw new Error('Cache Service Url not found, unable to restore cache.')\n  }\n\n  const url = `${baseUrl}_apis/artifactcache/${resource}`\n  core.debug(`Resource Url: ${url}`)\n  return url\n}\n\nfunction createAcceptHeader(type: string, apiVersion: string): string {\n  return `${type};api-version=${apiVersion}`\n}\n\nfunction getRequestOptions(): RequestOptions {\n  const requestOptions: RequestOptions = {\n    headers: {\n      Accept: createAcceptHeader('application/json', '6.0-preview.1')\n    }\n  }\n\n  return requestOptions\n}\n\nfunction createHttpClient(): HttpClient {\n  const token = process.env['ACTIONS_RUNTIME_TOKEN'] || ''\n  const bearerCredentialHandler = new BearerCredentialHandler(token)\n\n  return new HttpClient(\n    'actions/cache',\n    [bearerCredentialHandler],\n    getRequestOptions()\n  )\n}\n\nexport function getCacheVersion(\n  paths: string[],\n  compressionMethod?: CompressionMethod,\n  enableCrossOsArchive = false\n): string {\n  // don't pass changes upstream\n  const components = paths.slice()\n\n  // Add compression method to cache version to restore\n  // compressed cache as per compression method\n  if (compressionMethod) {\n    components.push(compressionMethod)\n  }\n\n  // Only check for windows platforms if enableCrossOsArchive is false\n  if (process.platform === 'win32' && !enableCrossOsArchive) {\n    components.push('windows-only')\n  }\n\n  // Add salt to cache version to support breaking changes in cache entry\n  components.push(versionSalt)\n\n  return crypto.createHash('sha256').update(components.join('|')).digest('hex')\n}\n\nexport async function getCacheEntry(\n  keys: string[],\n  paths: string[],\n  options?: InternalCacheOptions\n): Promise<ArtifactCacheEntry | null> {\n  const httpClient = createHttpClient()\n  const version = getCacheVersion(\n    paths,\n    options?.compressionMethod,\n    options?.enableCrossOsArchive\n  )\n  const resource = `cache?keys=${encodeURIComponent(\n    keys.join(',')\n  )}&version=${version}`\n\n  const response = await retryTypedResponse('getCacheEntry', async () =>\n    httpClient.getJson<ArtifactCacheEntry>(getCacheApiUrl(resource))\n  )\n  // Cache not found\n  if (response.statusCode === 204) {\n    // List cache for primary key only if cache miss occurs\n    if (core.isDebug()) {\n      await printCachesListForDiagnostics(keys[0], httpClient, version)\n    }\n    return null\n  }\n  if (!isSuccessStatusCode(response.statusCode)) {\n    throw new Error(`Cache service responded with ${response.statusCode}`)\n  }\n\n  const cacheResult = response.result\n  const cacheDownloadUrl = cacheResult?.archiveLocation\n  if (!cacheDownloadUrl) {\n    // Cache achiveLocation not found. This should never happen, and hence bail out.\n    throw new Error('Cache not found.')\n  }\n  core.setSecret(cacheDownloadUrl)\n  core.debug(`Cache Result:`)\n  core.debug(JSON.stringify(cacheResult))\n\n  return cacheResult\n}\n\nasync function printCachesListForDiagnostics(\n  key: string,\n  httpClient: HttpClient,\n  version: string\n): Promise<void> {\n  const resource = `caches?key=${encodeURIComponent(key)}`\n  const response = await retryTypedResponse('listCache', async () =>\n    httpClient.getJson<ArtifactCacheList>(getCacheApiUrl(resource))\n  )\n  if (response.statusCode === 200) {\n    const cacheListResult = response.result\n    const totalCount = cacheListResult?.totalCount\n    if (totalCount && totalCount > 0) {\n      core.debug(\n        `No matching cache found for cache key '${key}', version '${version} and scope ${process.env['GITHUB_REF']}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key \\nOther caches with similar key:`\n      )\n      for (const cacheEntry of cacheListResult?.artifactCaches || []) {\n        core.debug(\n          `Cache Key: ${cacheEntry?.cacheKey}, Cache Version: ${cacheEntry?.cacheVersion}, Cache Scope: ${cacheEntry?.scope}, Cache Created: ${cacheEntry?.creationTime}`\n        )\n      }\n    }\n  }\n}\n\nexport async function downloadCacheToBuffer(archiveLocation: string, options?: DownloadOptions): Promise<Buffer> {\n  let lastWrittenChunkLocation: number = 0\n  let writtenBytes: number = 0\n  interface IChunk {\n    chunkBuffer: Buffer\n    chunkLength: number\n    bufferPosition: number\n  }\n  const bufferChunks: IChunk[] = []\n\n  await downloadCacheInternal(archiveLocation,\n    (chunkBuffer, chunkLength = chunkBuffer.length, bufferPosition = lastWrittenChunkLocation) => {\n      bufferChunks.push({ chunkBuffer, chunkLength, bufferPosition })\n      lastWrittenChunkLocation = bufferPosition + chunkLength\n      writtenBytes = writtenBytes > lastWrittenChunkLocation ? writtenBytes : lastWrittenChunkLocation\n    },\n    () => writtenBytes,\n    options\n  )\n\n  if (bufferChunks.length === 1) {\n    const [{ chunkBuffer }] = bufferChunks\n    return chunkBuffer;\n  } else if (bufferChunks.length === 0) {\n    return Buffer.alloc(0)\n  } else {\n    const finalBuffer = Buffer.alloc(writtenBytes)\n    for (const { chunkBuffer: buffer, bufferPosition: position, chunkLength: length} of bufferChunks) {\n      buffer.copy(finalBuffer, position, 0, length)\n    }\n\n    return finalBuffer\n}\n}\n\nexport async function downloadCache(\n  archiveLocation: string,\n  archivePath: string,\n  options?: DownloadOptions\n): Promise<void> {\n  const archiveDescriptor = await fs.promises.open(archivePath, 'w')\n\n  try {\n    await downloadCacheInternal(archiveLocation,\n      async (buffer, length, position) => {\n        await archiveDescriptor.write(buffer, 0, length, position)\n      },\n      () => utils.getArchiveFileSizeInBytes(archivePath),\n      options\n    )\n  } finally {\n    await archiveDescriptor.close()\n  }\n}\n\nasync function downloadCacheInternal(\n  archiveLocation: string,\n  onChunk: ChunkWriteCallback,\n  getWrittenLength: () => number,\n  options: DownloadOptions | undefined\n): Promise<void> {\n  const archiveUrl = new URL(archiveLocation)\n  const downloadOptions = getDownloadOptions(options)\n\n  if (archiveUrl.hostname.endsWith('.blob.core.windows.net')) {\n    if (downloadOptions.useAzureSdk) {\n      // Use Azure storage SDK to download caches hosted on Azure to improve speed and reliability.\n      await downloadCacheStorageSDK(\n        archiveLocation,\n        onChunk,\n        getWrittenLength,\n        downloadOptions\n      )\n    } else if (downloadOptions.concurrentBlobDownloads) {\n      // Use concurrent implementation with HttpClient to work around blob SDK issue\n      await downloadCacheHttpClientConcurrent(\n        archiveLocation,\n        onChunk,\n        downloadOptions\n      )\n    } else {\n      // Otherwise, download using the Actions http-client.\n      await downloadCacheHttpClient(archiveLocation, onChunk, getWrittenLength)\n    }\n  } else {\n    await downloadCacheHttpClient(archiveLocation, onChunk, getWrittenLength)\n  }\n}\n\n// Reserve Cache\nexport async function reserveCache(\n  key: string,\n  paths: string[],\n  options?: InternalCacheOptions\n): Promise<ITypedResponseWithError<ReserveCacheResponse>> {\n  const httpClient = createHttpClient()\n  const version = getCacheVersion(\n    paths,\n    options?.compressionMethod,\n    options?.enableCrossOsArchive\n  )\n\n  const reserveCacheRequest: ReserveCacheRequest = {\n    key,\n    version,\n    cacheSize: options?.cacheSize\n  }\n  const response = await retryTypedResponse('reserveCache', async () =>\n    httpClient.postJson<ReserveCacheResponse>(\n      getCacheApiUrl('caches'),\n      reserveCacheRequest\n    )\n  )\n  return response\n}\n\nfunction getContentRange(start: number, end: number): string {\n  // Format: `bytes start-end/filesize\n  // start and end are inclusive\n  // filesize can be *\n  // For a 200 byte chunk starting at byte 0:\n  // Content-Range: bytes 0-199/*\n  return `bytes ${start}-${end}/*`\n}\n\nasync function uploadChunk(\n  httpClient: HttpClient,\n  resourceUrl: string,\n  openStream: () => NodeJS.ReadableStream,\n  start: number,\n  end: number\n): Promise<void> {\n  core.debug(\n    `Uploading chunk of size ${\n      end - start + 1\n    } bytes at offset ${start} with content range: ${getContentRange(\n      start,\n      end\n    )}`\n  )\n  const additionalHeaders = {\n    'Content-Type': 'application/octet-stream',\n    'Content-Range': getContentRange(start, end)\n  }\n\n  const uploadChunkResponse = await retryHttpClientResponse(\n    `uploadChunk (start: ${start}, end: ${end})`,\n    async () =>\n      httpClient.sendStream(\n        'PATCH',\n        resourceUrl,\n        openStream(),\n        additionalHeaders\n      )\n  )\n\n  if (!isSuccessStatusCode(uploadChunkResponse.message.statusCode)) {\n    throw new Error(\n      `Cache service responded with ${uploadChunkResponse.message.statusCode} during upload chunk.`\n    )\n  }\n}\n\nasync function uploadFile(\n  httpClient: HttpClient,\n  cacheId: number,\n  fileSize: number,\n  getReadStreamForChunk: GetStreamForChunk,\n  options?: UploadOptions\n): Promise<void> {\n  // Upload Chunks\n  const resourceUrl = getCacheApiUrl(`caches/${cacheId.toString()}`)\n  const uploadOptions = getUploadOptions(options)\n\n  const concurrency = utils.assertDefined(\n    'uploadConcurrency',\n    uploadOptions.uploadConcurrency\n  )\n  const maxChunkSize = utils.assertDefined(\n    'uploadChunkSize',\n    uploadOptions.uploadChunkSize\n  )\n\n  const parallelUploads = [...new Array(concurrency).keys()]\n  core.debug('Awaiting all uploads')\n  let offset = 0\n\n  await Promise.all(\n    parallelUploads.map(async () => {\n      while (offset < fileSize) {\n        const chunkSize = Math.min(fileSize - offset, maxChunkSize)\n        const start = offset\n        const end = offset + chunkSize - 1\n        offset += maxChunkSize\n\n        await uploadChunk(\n          httpClient,\n          resourceUrl,\n          () => getReadStreamForChunk(start, end),\n          start,\n          end\n        )\n      }\n    })\n  )\n}\n\nasync function commitCache(\n  httpClient: HttpClient,\n  cacheId: number,\n  filesize: number\n): Promise<TypedResponse<null>> {\n  const commitCacheRequest: CommitCacheRequest = {size: filesize}\n  return await retryTypedResponse('commitCache', async () =>\n    httpClient.postJson<null>(\n      getCacheApiUrl(`caches/${cacheId.toString()}`),\n      commitCacheRequest\n    )\n  )\n}\n\nexport async function saveCache(\n  cacheId: number,\n  archivePath: string,\n  options?: UploadOptions\n): Promise<void> {\n  const fileSize = utils.getArchiveFileSizeInBytes(archivePath)\n  const fd = fs.openSync(archivePath, 'r')\n\n  try {\n    await saveCacheInner(\n      cacheId,\n      (start, end) => fs\n        .createReadStream(archivePath, {\n          fd,\n          start,\n          end,\n          autoClose: false\n        })\n        .on('error', error => {\n          throw new Error(\n            `Cache upload failed because file read failed with ${error.message}`\n          )\n        }),\n      fileSize,\n      options\n    )\n  } finally {\n    fs.closeSync(fd)\n  }\n}\n\nexport async function saveCacheBuffer(\n  cacheId: number,\n  buffer: Buffer,\n  options?: UploadOptions\n): Promise<void> {\n  await saveCacheInner(\n    cacheId,\n    (start, end) => ReadableStream.from(buffer.subarray(start, end + 1)),\n    buffer.length,\n    options\n  )\n}\n\nasync function saveCacheInner(\n  cacheId: number,\n  getReadStreamForChunk: GetStreamForChunk,\n  cacheSize: number,\n  options?: UploadOptions\n): Promise<void> {\n  const httpClient = createHttpClient()\n\n  core.debug('Upload cache')\n  await uploadFile(\n    httpClient,\n    cacheId,\n    cacheSize,\n    getReadStreamForChunk,\n    options\n  )\n\n  // Commit Cache\n  core.debug('Committing cache')\n  core.info(\n    `Cache Size: ~${Math.round(cacheSize / (1024 * 1024))} MB (${cacheSize} B)`\n  )\n\n  const commitCacheResponse = await commitCache(httpClient, cacheId, cacheSize)\n  if (!isSuccessStatusCode(commitCacheResponse.statusCode)) {\n    throw new Error(\n      `Cache service responded with ${commitCacheResponse.statusCode} during commit cache.`\n    )\n  }\n\n  core.info('Cache saved successfully')\n}"]}